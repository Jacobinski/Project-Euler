# A triangle number is generated by adding successive natural numbers. For instance: the seventh triangle number is 1+2+3+4+5+6+7=28. This triangle number has six divisors: 1,2,4,5,14,28. Find the first triangle number to have over 500 divisors.

from time import clock

start = clock()
divisor_threshold = 500
triangle_counter = 1 
triangle_number = 1 
primes = []
found = False

# Note: We can calculate the # of divisors by the multiplication of (power + 1) of each of the prime numbers used to create the number. Ex. 24 divisors -> 1, 2 , 3, 4, 6, 8, 12, 24 (8 divisors). 24 = 2^3 * 3^1 -> (3+1)(1+1)=8 divisors. This holds true in general http://mathforum.org/library/drmath/view/55843.html 

# Note: 1 is not a prime for our purposes (it can be multiplied infinitely to make the same product!). We will thus start such that our first triangle number is square.

# Note 2: We only have to check up to the square root of a number to check if it is prime http://stackoverflow.com/questions/5811151/why-do-we-check-upto-the-square-root-of-a-prime-number-to-determine-if-it-is-pri

while found is not True:
    triangle_counter += 1 # Adds one to the counter
    triangle_number  += triangle_counter # Creates the next triangle number
    if all(triangle_counter % prime is not 0 for prime in primes): 
        primes.append(triangle_counter) # We get a new prime
    #Now do the divisors with our primes and a temp variable
    divisor_num = 1 # Temporary divisor counter
    # Let's avoid that sqrt(number) checking for now...
    for prime in primes:
        number = triangle_number # For the manipulation of triangle_number
        counter = 0 # Counts the number of occurences of a prime factor
        while(number % prime is 0):
            counter += 1
            number = number / prime
        if counter > 0:
            divisor_num *= counter + 1
    if divisor_num > 500:
        found = True


end = clock()
print('The first triangle number with over 500 divisors is {}'.format(triangle_number))
print('This computation took {} seconds'.format(end-start))
